# 자바스크립트 핵심개념(클로저)

## 클로저 (Closure)
- ### 개념
  ***이미 생명주기가 끝난 외부함수의 변수를 참조하는 함수*** (스코프체인 때문에 참조가 가능하다.)  
  외부함수가 호출되면 함수가 반환되는데 이를 클로저라 하고 클로저에서 참조할 수 있는 외부함수의 변수를 자유변수라 한다.

- ### 활용
  1. 특정 함수에 사용자가 정의한 객체의 메서드 연결하기 [[code 보기]](https://jsbin.com/janigaw/edit?js,console)  
  정해진 형식의 함수를 콜백해주는 라이브러리가 있을 경우
  그 정해진 형식과는 다른 형식의 사용자 정의 함수를 호출할 때 유용하게 사용.  
  ex) onclick, onmouseovedr의 콜백함수 인자의 경우 event인데,
  event 외의 원하는 인자를 더 추가한 이벤트 핸들러를 사용하고 싶을 때 적절함. [[code 보기]](https://jsbin.com/babagoh/edit?html,js,output)
  2. 함수의 캡슐화 [[code 보기]](https://jsbin.com/sofeyis/edit?js,console)  
  클로저를 이용하여 프라이빗 메소드를 흉내낼 수 있다.  
  제한된 접근 뿐만 아니라 전역 네임스페이스를 관리할 수 있는 방법이다.

- ### 클로저와 반복문
  클로저 설명의 단골손님처럼 등장하는 예제이다. 코드로 이해해보자.
  ```
  function count() {
    for(var i = 1; i <= 5; i++) {
      setTimeout(function() {
        console.log(i);
      }, 1000);
    }
  }
  count();
  ```  
  1, 2, 3, 4, 5를 1초 후에 출력하는 의도로 만든 예제이다. 하지만 의도와는 다르게 6이 연속으로 5번 출력된다. 그 이유는 클로저 스코프 때문이다.  
  setTimeout()에 인자로 들어가는 익명함수는 자유 변수 i를 참조한다. 하지만 이 함수가 실행되는 시점은 count() 함수의 실행이 종료된 이후이며 i의 값은 6인 상태이기 때문에 모두 6이 출력된다.  
  그렇다면 1초 후에 실행되기 때문에 i의 값이 6으로 출력된 것이 라고 오해할 수 있다. 다음 코드를 살펴 보자.
  ```
  function count() {
  for(var i = 1; i <= 5; i++) {
      setTimeout(function() {
        console.log(i);
       }, 0); // 0 밀리초 즉 바로 실행되겠지? 라는 의도
    }
  }
  count();
  ```
  delay 시간을 0밀리초로 입력하였다. 출력 값은 1000밀리초와 입력했던 것과 마찬가지로 6이 5번 출력된다. 1초 동안 for loop가 다 돌아서 6으로 증가되었다? 라고 이해했다면 위 코드를 보고 멘붕이 올 것이다. 다시 한 번 아래 글을 읽어보자..
    1. setTimeout()의 콜백함수는 for문을 순회할 때는 5개의 실행 컨텍스트가 생성되어 콜백 큐에서 대기한다.  
    (for문을 순회할 때 setTimeout() 같은 브라우저(Web Api)의 이벤트 함수의 경우 콜백(이벤트) 큐라는 곳에 생성되어 메인 스레드의 종료를 대기 했다가 그 후에 실행되게 된다.)
    2. count() 함수의 실행이 종료된 후 차례대로 실행 후 종료된다.  
    (이때 참조된 자유 변수 i의 값은 count() 내부의 스코프를 가지게 되므로 호이스팅 되어 i값이 계속 변해 6으로 공유되게 된다.)
    
  콜백 함수가 실행될 때 count() 함수는 종료된 시점이고 i의 값은 6으로 증가된 상태이기 때문에 출력된 값은 모두 6이 된다.  
  즉, **콜백함수로 들어가는 익명함수의 실행시점은 count() 함수의 실행이 종료된 이후 일 수 밖에 없기 때문에 6이 출력되는 것이다.** (비동기)

  그래서 문제를 해결하기 위해 즉시 실행 함수(IIFE)를 사용하여 해결하게 된다. 즉시 실행 함수로 감싸주어 새로운 함수 스코프 범위를 지정해주는 것이다.   
  그러면 즉시실행 함수가 실행되면서 인자 n이 초기화 될 것이고, setTimeout() n은 스코프 체인을 통해 해당 변수를 참조하게 된다.
  ```
  function count() {
    for(var i = 1; i <= 5; i++) {
      (function(n) {
        setTimeout(function() {
          console.log(n);
        }, 0);
      })(i);
    }
  }
  count(); // 1 2 3 4 5 의도한 대로 값이 출력된다.
  ```
  또는 ES6의 let을 이용하면 문제를 해결 할 수 있다.
  ```
  function count() {
    for(let i = 1; i <= 5; i++) { // var -> let
      setTimeout(function() {
        console.log(n);
      }, 0);
    }
  }
  count(); // 1 2 3 4 5 의도한 대로 값이 출력된다.
  ```
  다시 한 번 의문점이 생길 것이다. let으로 선언한 for문이 모두 순회한 뒤 콜백함수가 실행되니까 이거 역시 i가 6이어야 되는거 아니야?

  MDN의 for문을 살펴보면 다음과 같이 쓰여져 있다. 

  > var 키워드로 선언한 변수는 반복문에 제한되지 않습니다. 즉 for 문과 같은 범위scope에 위치합니다. let 키워드로 선언한 변수는 반복문의 **지역 변수**가 됩니다.

  즉, let은 변수를 호이스팅 하지 않고 블록 스코프를 가지기 때문에 현재 실행컨텍스트의 변수객체에는 i가 존재하여 의도한 대로 값이 출력된다.

 - ### 참조
    > 인사이드 자바스크립트 송형주, 고현준 지음  
    > [MDN for](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Statements/for)